'use strict';

// TODO Try to add depth for only win search
// Game state class
TRIPLET.State = function () {

  var cfg = TRIPLET.config.general,
      rule = TRIPLET.config.rules,
      players = TRIPLET.config.players,
      Player = TRIPLET.Player,
      _State;

  _State = function State(source) {
    if (source instanceof _State) {
      this.turn = source.turn;
      this.lastMove = source.lastMove;
      this.players = source.players;
      this.orders = source.orders;
      this.field = this.fill(function (row, col) {
        return source.field[row][col];
      });
    } else {
      this.turn = 0;
      this.lastMove = {};
      this.players = players.map(Player);
      this.orders = {
        normal: this.makeNormalOrder().reverse(),
        spiral: this.makeSpiralOrder().reverse()
      };
      this.field = this.fill(function () {
        return rule.emptyVal;
      });
    }
  };

  _State.prototype = {

    constructor: _State,

    // Initialize methods
    fill: function fill(filler) {
      var row,
          col,
          field = [];
      while (field.push([]) <= cfg.rows) {}
      for (row = cfg.rows; row--;) {
        for (col = cfg.columns; col--;) {
          field[row][col] = filler(row, col);
        }
      }return field;
    },

    makeNormalOrder: function makeNormalOrder() {
      function getRowCol(e, i) {
        return [~ ~(i / cfg.columns), i % cfg.columns];
      }
      return Array.apply(null, Array(cfg.maxTurns)).map(getRowCol);
    },

    makeSpiralOrder: function () {

      var ORDER_SPIRAL_N_CCW = [[1, 0], [0, -1], [-1, 0], [0, 1]];

      return function () {
        var row = ~ ~(cfg.rows / 2),
            col = ~ ~(cfg.columns / 2),
            result = [],
            vector,
            turns = 0,
            straight = 0,
            beforeTurn = 0,
            searched = 0;
        while (searched < cfg.maxTurns) {
          if (this.cellInRange(row, col)) {
            result.push([row, col]);
            searched++;
          }
          vector = turns % 4;
          row += ORDER_SPIRAL_N_CCW[vector][0];
          col += ORDER_SPIRAL_N_CCW[vector][1];
          if (beforeTurn-- === 0) {
            turns++;
            beforeTurn = straight;
            if (vector % 2 === 0) straight++;
          }
        }
        return result;
      };
    }(),

    // General methods
    copy: function copy() {
      return new _State(this);
    },

    getCurrentPlayer: function getCurrentPlayer() {
      return this.players[~ ~(this.turn / rule.signsPerRound) % this.players.length];
    },

    cellInRange: function cellInRange(row, col) {
      return row >= 0 && row < cfg.rows && col >= 0 && col < cfg.columns;
    },

    cellIsEmpty: function cellIsEmpty(row, col) {
      return this.field[row][col] === rule.emptyVal;
    },

    visitCells: function visitCells(order, fn, filter) {
      for (var i = order.length; i--;) {
        if (filter.apply(this, order[i]) && fn.apply(this, order[i])) return true;
      }
    },

    makeMove: function makeMove(row, col) {
      if (this.cellIsEmpty(row, col) && this.cellInRange(row, col)) {
        this.lastMove = {
          row: row, col: col,
          player: this.getCurrentPlayer()
        };
        this.field[row][col] = this.lastMove.player.queue;
        this.turn++;
        return this;
      }
    },

    // Find win or tie methods
    findWin: function () {

      var DIRECTIONS = [[0, 1], [1, 0], [-1, 1], [1, 1]],
          DEFAULT_LIMITS = [Infinity, 0];

      return function (method, codes, limits, row, col) {

        function getInlineCells(lim, dirR, dirC, counter) {
          var nextRow = row + dirR * counter,
              nextCol = col + dirC * counter,
              i;
          if (this.cellInRange(nextRow, nextCol)) for (i = 0; i < codes.length; i++) {
            if (this.field[nextRow][nextCol] === codes[i] && lim[i]-- > 0) return getInlineCells.call(this, lim, dirR, dirC, counter + 1);
          }return counter;
        }

        function getWinLine(dir) {
          var lim = limits.slice(),
              len0 = getInlineCells.call(this, lim, dir[0], dir[1], 0),
              len1 = getInlineCells.call(this, lim, -dir[0], -dir[1], 1) - 1;
          if (len0 + len1 >= rule.winLength) return {
            codes: codes, limits: limits, remainLim: lim,
            lengths: [len0, len1], direction: dir
          };
        }

        if (method !== 'map' && method !== 'some') method = 'map';
        if (!Array.isArray(codes)) codes = [this.lastMove.player.queue, rule.emptyVal];
        if (!Array.isArray(limits)) limits = DEFAULT_LIMITS;
        if (!this.cellInRange(row, col)) {
          row = this.lastMove.row;
          col = this.lastMove.col;
        }
        if (codes.length === limits.length) return DIRECTIONS[method](getWinLine, this);
        throw new Error('Wrong findWin method initialization.');
      };
    }(),

    isTie: function isTie() {
      function somebodyCanWin(row, col) {
        return this.players.some(function canWin(player) {
          var remains = player.maxTurns - player.getTurnsCount(this.turn);
          return this.findWin('some', [player.queue, rule.emptyVal], [rule.winLength, remains], row, col);
        }, this);
      }
      return !(this.turn < rule.minTurnsForTie || this.visitCells(this.orders.normal, somebodyCanWin, this.cellIsEmpty));
    },

    // Simple heuristics
    getMoveHeuristicScore: function getMoveHeuristicScore(scores) {

      var score = 0,
          lastPlayerID = this.lastMove.player.queue,
          playersCount = this.players.length,
          i,
          playerID;

      function scoreSignsAround() {
        var codes = [playerID, rule.emptyVal, lastPlayerID],
            limits = [cfg.maxLineLength, Infinity, 1],
            probableWins;
        if (playerID === lastPlayerID) limits[2] = 0;
        probableWins = this.findWin('map', codes, limits, this.lastMove.row, this.lastMove.col);
        return probableWins.reduce(function (score, win) {
          if (win) score += Math.pow(4, cfg.maxLineLength - win.remainLim[0]) - 1;
          return score;
        }, 0); // Long line should be scored higher than 4 short lines
      }

      function ratio(i) {
        switch (i) {
          case 0:
            return scores.sign.own;
          case 1:
            return scores.sign.mainEnemy;
          default:
            return scores.sign.enemy;
        }
      }

      scores = scores || this.lastMove.player.ai.score;
      for (i = 0; i < playersCount; i++) {
        playerID = (lastPlayerID + i) % playersCount;
        if (this.findWin('some', [playerID, rule.emptyVal])) return scores.win * ratio(i);
        score += scoreSignsAround.call(this) * ratio(i);
      }
      if (this.isTie()) return scores.tie;
      return score;
    },

    // NegaMax implementation with fail-soft alpha-beta pruning
    getMoveMinimaxScore: function getMoveMinimaxScore(maxPlayer, alpha, beta, depth) {

      var isMax = maxPlayer === this.getCurrentPlayer();

      function prepare() {
        maxPlayer = this.lastMove.player;
        alpha = -Infinity;
        beta = Infinity;
        depth = maxPlayer.ai.depth;
      }

      function rateMove(row, col) {
        var score = this.copy().makeMove(row, col).getMoveMinimaxScore(maxPlayer, alpha, beta, depth - 1);
        if (isMax) alpha = Math.max(alpha, score);else beta = Math.min(beta, score);
        return alpha >= beta;
      }

      if (arguments.length < 4) prepare.call(this);
      if (depth <= 0 || this.findWin('some') || this.isTie()) return this.getMoveHeuristicScore(maxPlayer.ai.score) * (maxPlayer === this.lastMove.player ? 1 : -1) * (depth / rule.turnsPerRound + 1);
      this.visitCells(this.orders.spiral, rateMove, this.cellIsEmpty);
      return isMax ? alpha : beta;
    },

    findNextBestMoves: function findNextBestMoves() {

      var i,
          scoreTypes = 0,
          scores = [],
          tolerance = this.getCurrentPlayer().ai.tolerance;

      function findHighScore(i) {
        var max = Math.max.apply(null, scores.map(function (o) {
          return o.score[i];
        })) - tolerance;
        return scores.filter(function (val) {
          return val.score[i] >= max;
        });
      }

      function rateCell(row, col) {
        var deep = this.copy().makeMove(row, col),
            score = [deep.getMoveMinimaxScore(), deep.getMoveHeuristicScore()];
        if (!scoreTypes) scoreTypes = score.length;
        scores.push({ row: row, col: col, score: score });
      }

      this.visitCells(this.orders.normal, rateCell, this.cellIsEmpty);
      for (i = 0; i < scoreTypes; i++) {
        scores = findHighScore(i);
      }return scores;
    }

  };

  return _State;
}();
//# sourceMappingURL=data:application/json;base64,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QUNJLFFBQVEsQ0FBQyxLQUFLLG1CQUFMLEVBQUQsRUFBNkIsS0FBSyxxQkFBTCxFQUE3QixDQURaO0FBRUEsWUFBSSxDQUFDLFVBQUwsRUFBaUIsYUFBYSxNQUFNLE1BQW5CO0FBQ2pCLGVBQU8sSUFBUCxDQUFZLEVBQUUsS0FBSyxHQUFQLEVBQVksS0FBSyxHQUFqQixFQUFzQixPQUFPLEtBQTdCLEVBQVo7QUFDRDs7QUFFRCxXQUFLLFVBQUwsQ0FBZ0IsS0FBSyxNQUFMLENBQVksTUFBNUIsRUFBb0MsUUFBcEMsRUFBOEMsS0FBSyxXQUFuRDtBQUNBLFdBQUssSUFBSSxDQUFULEVBQVksSUFBSSxVQUFoQixFQUE0QixHQUE1QjtBQUFpQyxpQkFBUyxjQUFjLENBQWQsQ0FBVDtBQUFqQyxPQUNBLE9BQU8sTUFBUDtBQUVEOztBQTFPZSxHQUFsQjs7QUE4T0EsU0FBTyxNQUFQO0FBRUMsQ0EvUWUsRUFBaEIiLCJmaWxlIjoianMvc3RhdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPIFRyeSB0byBhZGQgZGVwdGggZm9yIG9ubHkgd2luIHNlYXJjaFxyXG4vLyBHYW1lIHN0YXRlIGNsYXNzXHJcblRSSVBMRVQuU3RhdGUgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG52YXIgY2ZnID0gVFJJUExFVC5jb25maWcuZ2VuZXJhbCxcclxuICAgIHJ1bGUgPSBUUklQTEVULmNvbmZpZy5ydWxlcyxcclxuICAgIHBsYXllcnMgPSBUUklQTEVULmNvbmZpZy5wbGF5ZXJzLFxyXG4gICAgUGxheWVyID0gVFJJUExFVC5QbGF5ZXIsXHJcbiAgICBTdGF0ZTtcclxuXHJcblN0YXRlID0gZnVuY3Rpb24oc291cmNlKSB7XHJcbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFN0YXRlKSB7XHJcbiAgICB0aGlzLnR1cm4gPSBzb3VyY2UudHVybjtcclxuICAgIHRoaXMubGFzdE1vdmUgPSBzb3VyY2UubGFzdE1vdmU7XHJcbiAgICB0aGlzLnBsYXllcnMgPSBzb3VyY2UucGxheWVycztcclxuICAgIHRoaXMub3JkZXJzID0gc291cmNlLm9yZGVycztcclxuICAgIHRoaXMuZmllbGQgPSB0aGlzLmZpbGwoZnVuY3Rpb24ocm93LCBjb2wpIHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5maWVsZFtyb3ddW2NvbF07XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy50dXJuID0gMDtcclxuICAgIHRoaXMubGFzdE1vdmUgPSB7fTtcclxuICAgIHRoaXMucGxheWVycyA9IHBsYXllcnMubWFwKFBsYXllcik7XHJcbiAgICB0aGlzLm9yZGVycyA9IHtcclxuICAgICAgbm9ybWFsOiB0aGlzLm1ha2VOb3JtYWxPcmRlcigpLnJldmVyc2UoKSxcclxuICAgICAgc3BpcmFsOiB0aGlzLm1ha2VTcGlyYWxPcmRlcigpLnJldmVyc2UoKVxyXG4gICAgfTtcclxuICAgIHRoaXMuZmllbGQgPSB0aGlzLmZpbGwoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBydWxlLmVtcHR5VmFsO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuU3RhdGUucHJvdG90eXBlID0ge1xyXG5cclxuICBjb25zdHJ1Y3RvcjogU3RhdGUsXHJcblxyXG4gIC8vIEluaXRpYWxpemUgbWV0aG9kc1xyXG4gIGZpbGw6IGZ1bmN0aW9uKGZpbGxlcikge1xyXG4gICAgdmFyIHJvdywgY29sLCBmaWVsZCA9IFtdO1xyXG4gICAgd2hpbGUgKGZpZWxkLnB1c2goW10pIDw9IGNmZy5yb3dzKSB7fVxyXG4gICAgZm9yIChyb3cgPSBjZmcucm93czsgcm93LS07KVxyXG4gICAgICBmb3IgKGNvbCA9IGNmZy5jb2x1bW5zOyBjb2wtLTspXHJcbiAgICAgICAgZmllbGRbcm93XVtjb2xdID0gZmlsbGVyKHJvdywgY29sKTtcclxuICAgIHJldHVybiBmaWVsZDtcclxuICB9LFxyXG5cclxuICBtYWtlTm9ybWFsT3JkZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0Um93Q29sKGUsIGkpIHsgcmV0dXJuIFt+fihpIC8gY2ZnLmNvbHVtbnMpLCBpICUgY2ZnLmNvbHVtbnNdOyB9XHJcbiAgICByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoY2ZnLm1heFR1cm5zKSkubWFwKGdldFJvd0NvbCk7XHJcbiAgfSxcclxuXHJcbiAgbWFrZVNwaXJhbE9yZGVyOiAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIE9SREVSX1NQSVJBTF9OX0NDVyA9IFtbMSwgMF0sIFswLCAtMV0sIFstMSwgMF0sIFswLCAxXV07XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcm93ID0gfn4oY2ZnLnJvd3MgLyAyKSxcclxuICAgICAgICAgIGNvbCA9IH5+KGNmZy5jb2x1bW5zIC8gMiksXHJcbiAgICAgICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAgIHZlY3RvcixcclxuICAgICAgICAgIHR1cm5zID0gMCwgc3RyYWlnaHQgPSAwLCBiZWZvcmVUdXJuID0gMCwgc2VhcmNoZWQgPSAwO1xyXG4gICAgICB3aGlsZSAoc2VhcmNoZWQgPCBjZmcubWF4VHVybnMpIHtcclxuICAgICAgICBpZiAodGhpcy5jZWxsSW5SYW5nZShyb3csIGNvbCkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKFtyb3csIGNvbF0pO1xyXG4gICAgICAgICAgc2VhcmNoZWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjdG9yID0gdHVybnMgJSA0O1xyXG4gICAgICAgIHJvdyArPSBPUkRFUl9TUElSQUxfTl9DQ1dbdmVjdG9yXVswXTtcclxuICAgICAgICBjb2wgKz0gT1JERVJfU1BJUkFMX05fQ0NXW3ZlY3Rvcl1bMV07XHJcbiAgICAgICAgaWYgKGJlZm9yZVR1cm4tLSA9PT0gMCkge1xyXG4gICAgICAgICAgdHVybnMrKztcclxuICAgICAgICAgIGJlZm9yZVR1cm4gPSBzdHJhaWdodDtcclxuICAgICAgICAgIGlmICh2ZWN0b3IgJSAyID09PSAwKSBzdHJhaWdodCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgfSkoKSxcclxuXHJcbiAgLy8gR2VuZXJhbCBtZXRob2RzXHJcbiAgY29weTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0YXRlKHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIGdldEN1cnJlbnRQbGF5ZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGxheWVyc1t+fih0aGlzLnR1cm4gLyBydWxlLnNpZ25zUGVyUm91bmQpICVcclxuICAgICAgICB0aGlzLnBsYXllcnMubGVuZ3RoXTtcclxuICB9LFxyXG5cclxuICBjZWxsSW5SYW5nZTogZnVuY3Rpb24ocm93LCBjb2wpIHtcclxuICAgIHJldHVybiByb3cgPj0gMCAmJiByb3cgPCBjZmcucm93cyAmJiBjb2wgPj0gMCAmJiBjb2wgPCBjZmcuY29sdW1ucztcclxuICB9LFxyXG5cclxuICBjZWxsSXNFbXB0eTogZnVuY3Rpb24ocm93LCBjb2wpIHtcclxuICAgIHJldHVybiB0aGlzLmZpZWxkW3Jvd11bY29sXSA9PT0gcnVsZS5lbXB0eVZhbDtcclxuICB9LFxyXG5cclxuICB2aXNpdENlbGxzOiBmdW5jdGlvbihvcmRlciwgZm4sIGZpbHRlcikge1xyXG4gICAgZm9yICh2YXIgaSA9IG9yZGVyLmxlbmd0aDsgaS0tOylcclxuICAgICAgaWYgKGZpbHRlci5hcHBseSh0aGlzLCBvcmRlcltpXSkgJiYgZm4uYXBwbHkodGhpcywgb3JkZXJbaV0pKSByZXR1cm4gdHJ1ZTtcclxuICB9LFxyXG5cclxuICBtYWtlTW92ZTogZnVuY3Rpb24ocm93LCBjb2wpIHtcclxuICAgIGlmICh0aGlzLmNlbGxJc0VtcHR5KHJvdywgY29sKSAmJiB0aGlzLmNlbGxJblJhbmdlKHJvdywgY29sKSkge1xyXG4gICAgICB0aGlzLmxhc3RNb3ZlID0ge1xyXG4gICAgICAgIHJvdzogcm93LCBjb2w6IGNvbCxcclxuICAgICAgICBwbGF5ZXI6IHRoaXMuZ2V0Q3VycmVudFBsYXllcigpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZmllbGRbcm93XVtjb2xdID0gdGhpcy5sYXN0TW92ZS5wbGF5ZXIucXVldWU7XHJcbiAgICAgIHRoaXMudHVybisrO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBGaW5kIHdpbiBvciB0aWUgbWV0aG9kc1xyXG4gIGZpbmRXaW46IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgRElSRUNUSU9OUyA9IFtbMCwgMV0sIFsxLCAwXSwgWy0xLCAxXSwgWzEsIDFdXSxcclxuICAgICAgICBERUZBVUxUX0xJTUlUUyA9IFtJbmZpbml0eSwgMF07XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1ldGhvZCwgY29kZXMsIGxpbWl0cywgcm93LCBjb2wpIHtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldElubGluZUNlbGxzKGxpbSwgZGlyUiwgZGlyQywgY291bnRlcikge1xyXG4gICAgICAgIHZhciBuZXh0Um93ID0gcm93ICsgZGlyUiAqIGNvdW50ZXIsXHJcbiAgICAgICAgICAgIG5leHRDb2wgPSBjb2wgKyBkaXJDICogY291bnRlciwgaTtcclxuICAgICAgICBpZiAodGhpcy5jZWxsSW5SYW5nZShuZXh0Um93LCBuZXh0Q29sKSlcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmllbGRbbmV4dFJvd11bbmV4dENvbF0gPT09IGNvZGVzW2ldICYmIGxpbVtpXS0tID4gMClcclxuICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5saW5lQ2VsbHMuY2FsbCh0aGlzLCBsaW0sIGRpclIsIGRpckMsIGNvdW50ZXIgKyAxKTtcclxuICAgICAgICByZXR1cm4gY291bnRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZ2V0V2luTGluZShkaXIpIHtcclxuICAgICAgICB2YXIgbGltID0gbGltaXRzLnNsaWNlKCksXHJcbiAgICAgICAgICAgIGxlbjAgPSBnZXRJbmxpbmVDZWxscy5jYWxsKHRoaXMsIGxpbSwgZGlyWzBdLCBkaXJbMV0sIDApLFxyXG4gICAgICAgICAgICBsZW4xID0gZ2V0SW5saW5lQ2VsbHMuY2FsbCh0aGlzLCBsaW0sIC1kaXJbMF0sIC1kaXJbMV0sIDEpIC0gMTtcclxuICAgICAgICBpZiAobGVuMCArIGxlbjEgPj0gcnVsZS53aW5MZW5ndGgpIHJldHVybiB7XHJcbiAgICAgICAgICBjb2RlczogY29kZXMsIGxpbWl0czogbGltaXRzLCByZW1haW5MaW06IGxpbSxcclxuICAgICAgICAgIGxlbmd0aHM6IFtsZW4wLCBsZW4xXSwgZGlyZWN0aW9uOiBkaXJcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobWV0aG9kICE9PSAnbWFwJyAmJiBtZXRob2QgIT09ICdzb21lJykgbWV0aG9kID0gJ21hcCc7XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2RlcykpXHJcbiAgICAgICAgY29kZXMgPSBbdGhpcy5sYXN0TW92ZS5wbGF5ZXIucXVldWUsIHJ1bGUuZW1wdHlWYWxdO1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGltaXRzKSkgbGltaXRzID0gREVGQVVMVF9MSU1JVFM7XHJcbiAgICAgIGlmICghdGhpcy5jZWxsSW5SYW5nZShyb3csIGNvbCkpIHtcclxuICAgICAgICByb3cgPSB0aGlzLmxhc3RNb3ZlLnJvdztcclxuICAgICAgICBjb2wgPSB0aGlzLmxhc3RNb3ZlLmNvbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29kZXMubGVuZ3RoID09PSBsaW1pdHMubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBESVJFQ1RJT05TW21ldGhvZF0oZ2V0V2luTGluZSwgdGhpcyk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgZmluZFdpbiBtZXRob2QgaW5pdGlhbGl6YXRpb24uJyk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgfSkoKSxcclxuXHJcbiAgaXNUaWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgZnVuY3Rpb24gc29tZWJvZHlDYW5XaW4ocm93LCBjb2wpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGxheWVycy5zb21lKGZ1bmN0aW9uIGNhbldpbihwbGF5ZXIpIHtcclxuICAgICAgICB2YXIgcmVtYWlucyA9IHBsYXllci5tYXhUdXJucyAtIHBsYXllci5nZXRUdXJuc0NvdW50KHRoaXMudHVybik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFdpbignc29tZScsXHJcbiAgICAgICAgICAgIFtwbGF5ZXIucXVldWUsIHJ1bGUuZW1wdHlWYWxdLCBbcnVsZS53aW5MZW5ndGgsIHJlbWFpbnNdLCByb3csIGNvbCk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEodGhpcy50dXJuIDwgcnVsZS5taW5UdXJuc0ZvclRpZSB8fFxyXG4gICAgICAgIHRoaXMudmlzaXRDZWxscyh0aGlzLm9yZGVycy5ub3JtYWwsIHNvbWVib2R5Q2FuV2luLCB0aGlzLmNlbGxJc0VtcHR5KSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gU2ltcGxlIGhldXJpc3RpY3NcclxuICBnZXRNb3ZlSGV1cmlzdGljU2NvcmU6IGZ1bmN0aW9uKHNjb3Jlcykge1xyXG5cclxuICAgIHZhciBzY29yZSA9IDAsXHJcbiAgICAgICAgbGFzdFBsYXllcklEID0gdGhpcy5sYXN0TW92ZS5wbGF5ZXIucXVldWUsXHJcbiAgICAgICAgcGxheWVyc0NvdW50ID0gdGhpcy5wbGF5ZXJzLmxlbmd0aCxcclxuICAgICAgICBpLCBwbGF5ZXJJRDtcclxuXHJcbiAgICBmdW5jdGlvbiBzY29yZVNpZ25zQXJvdW5kKCkge1xyXG4gICAgICB2YXIgY29kZXMgPSBbcGxheWVySUQsIHJ1bGUuZW1wdHlWYWwsIGxhc3RQbGF5ZXJJRF0sXHJcbiAgICAgICAgICBsaW1pdHMgPSBbY2ZnLm1heExpbmVMZW5ndGgsIEluZmluaXR5LCAxXSxcclxuICAgICAgICAgIHByb2JhYmxlV2lucztcclxuICAgICAgaWYgKHBsYXllcklEID09PSBsYXN0UGxheWVySUQpIGxpbWl0c1syXSA9IDA7XHJcbiAgICAgIHByb2JhYmxlV2lucyA9IHRoaXMuZmluZFdpbihcclxuICAgICAgICAgICdtYXAnLCBjb2RlcywgbGltaXRzLCB0aGlzLmxhc3RNb3ZlLnJvdywgdGhpcy5sYXN0TW92ZS5jb2wpO1xyXG4gICAgICByZXR1cm4gcHJvYmFibGVXaW5zLnJlZHVjZShmdW5jdGlvbihzY29yZSwgd2luKSB7XHJcbiAgICAgICAgaWYgKHdpbikgc2NvcmUgKz0gTWF0aC5wb3coNCwgY2ZnLm1heExpbmVMZW5ndGggLSB3aW4ucmVtYWluTGltWzBdKSAtIDE7XHJcbiAgICAgICAgcmV0dXJuIHNjb3JlO1xyXG4gICAgICB9LCAwKTsgIC8vIExvbmcgbGluZSBzaG91bGQgYmUgc2NvcmVkIGhpZ2hlciB0aGFuIDQgc2hvcnQgbGluZXNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByYXRpbyhpKSB7XHJcbiAgICAgIHN3aXRjaCAoaSkge1xyXG4gICAgICBjYXNlIDA6IHJldHVybiBzY29yZXMuc2lnbi5vd247XHJcbiAgICAgIGNhc2UgMTogcmV0dXJuIHNjb3Jlcy5zaWduLm1haW5FbmVteTtcclxuICAgICAgZGVmYXVsdDogcmV0dXJuIHNjb3Jlcy5zaWduLmVuZW15O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2NvcmVzID0gc2NvcmVzIHx8IHRoaXMubGFzdE1vdmUucGxheWVyLmFpLnNjb3JlO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHBsYXllcnNDb3VudDsgaSsrKSB7XHJcbiAgICAgIHBsYXllcklEID0gKGxhc3RQbGF5ZXJJRCArIGkpICUgcGxheWVyc0NvdW50O1xyXG4gICAgICBpZiAodGhpcy5maW5kV2luKCdzb21lJywgW3BsYXllcklELCBydWxlLmVtcHR5VmFsXSkpXHJcbiAgICAgICAgcmV0dXJuIHNjb3Jlcy53aW4gKiByYXRpbyhpKTtcclxuICAgICAgc2NvcmUgKz0gc2NvcmVTaWduc0Fyb3VuZC5jYWxsKHRoaXMpICogcmF0aW8oaSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5pc1RpZSgpKSByZXR1cm4gc2NvcmVzLnRpZTtcclxuICAgIHJldHVybiBzY29yZTtcclxuXHJcbiAgfSxcclxuXHJcbiAgLy8gTmVnYU1heCBpbXBsZW1lbnRhdGlvbiB3aXRoIGZhaWwtc29mdCBhbHBoYS1iZXRhIHBydW5pbmdcclxuICBnZXRNb3ZlTWluaW1heFNjb3JlOiBmdW5jdGlvbihtYXhQbGF5ZXIsIGFscGhhLCBiZXRhLCBkZXB0aCkge1xyXG5cclxuICAgIHZhciBpc01heCA9IG1heFBsYXllciA9PT0gdGhpcy5nZXRDdXJyZW50UGxheWVyKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gcHJlcGFyZSgpIHtcclxuICAgICAgbWF4UGxheWVyID0gdGhpcy5sYXN0TW92ZS5wbGF5ZXI7XHJcbiAgICAgIGFscGhhID0gLUluZmluaXR5O1xyXG4gICAgICBiZXRhID0gSW5maW5pdHk7XHJcbiAgICAgIGRlcHRoID0gbWF4UGxheWVyLmFpLmRlcHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJhdGVNb3ZlKHJvdywgY29sKSB7XHJcbiAgICAgIHZhciBzY29yZSA9IHRoaXMuY29weSgpLm1ha2VNb3ZlKHJvdywgY29sKS5nZXRNb3ZlTWluaW1heFNjb3JlKFxyXG4gICAgICAgICAgbWF4UGxheWVyLCBhbHBoYSwgYmV0YSwgZGVwdGggLSAxKTtcclxuICAgICAgaWYgKGlzTWF4KSBhbHBoYSA9IE1hdGgubWF4KGFscGhhLCBzY29yZSk7XHJcbiAgICAgIGVsc2UgYmV0YSA9IE1hdGgubWluKGJldGEsIHNjb3JlKTtcclxuICAgICAgcmV0dXJuIGFscGhhID49IGJldGE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBwcmVwYXJlLmNhbGwodGhpcyk7XHJcbiAgICBpZiAoZGVwdGggPD0gMCB8fCB0aGlzLmZpbmRXaW4oJ3NvbWUnKSB8fCB0aGlzLmlzVGllKCkpXHJcbiAgICAgIHJldHVybiB0aGlzLmdldE1vdmVIZXVyaXN0aWNTY29yZShtYXhQbGF5ZXIuYWkuc2NvcmUpICpcclxuICAgICAgICAgIChtYXhQbGF5ZXIgPT09IHRoaXMubGFzdE1vdmUucGxheWVyID8gMSA6IC0xKSAqXHJcbiAgICAgICAgICAoZGVwdGggLyBydWxlLnR1cm5zUGVyUm91bmQgKyAxKTtcclxuICAgIHRoaXMudmlzaXRDZWxscyh0aGlzLm9yZGVycy5zcGlyYWwsIHJhdGVNb3ZlLCB0aGlzLmNlbGxJc0VtcHR5KTtcclxuICAgIHJldHVybiBpc01heCA/IGFscGhhIDogYmV0YTtcclxuXHJcbiAgfSxcclxuXHJcbiAgZmluZE5leHRCZXN0TW92ZXM6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBpLCBzY29yZVR5cGVzID0gMCxcclxuICAgICAgICBzY29yZXMgPSBbXSxcclxuICAgICAgICB0b2xlcmFuY2UgPSB0aGlzLmdldEN1cnJlbnRQbGF5ZXIoKS5haS50b2xlcmFuY2U7XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZEhpZ2hTY29yZShpKSB7XHJcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBzY29yZXMubWFwKGZ1bmN0aW9uKG8pIHtcclxuICAgICAgICByZXR1cm4gby5zY29yZVtpXTtcclxuICAgICAgfSkpIC0gdG9sZXJhbmNlO1xyXG4gICAgICByZXR1cm4gc2NvcmVzLmZpbHRlcihmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbC5zY29yZVtpXSA+PSBtYXg7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJhdGVDZWxsKHJvdywgY29sKSB7XHJcbiAgICAgIHZhciBkZWVwID0gdGhpcy5jb3B5KCkubWFrZU1vdmUocm93LCBjb2wpLFxyXG4gICAgICAgICAgc2NvcmUgPSBbZGVlcC5nZXRNb3ZlTWluaW1heFNjb3JlKCksIGRlZXAuZ2V0TW92ZUhldXJpc3RpY1Njb3JlKCldO1xyXG4gICAgICBpZiAoIXNjb3JlVHlwZXMpIHNjb3JlVHlwZXMgPSBzY29yZS5sZW5ndGg7XHJcbiAgICAgIHNjb3Jlcy5wdXNoKHsgcm93OiByb3csIGNvbDogY29sLCBzY29yZTogc2NvcmUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52aXNpdENlbGxzKHRoaXMub3JkZXJzLm5vcm1hbCwgcmF0ZUNlbGwsIHRoaXMuY2VsbElzRW1wdHkpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHNjb3JlVHlwZXM7IGkrKykgc2NvcmVzID0gZmluZEhpZ2hTY29yZShpKTtcclxuICAgIHJldHVybiBzY29yZXM7XHJcblxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5yZXR1cm4gU3RhdGU7XHJcblxyXG59KSgpO1xyXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
